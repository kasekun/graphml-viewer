"""
GraphML file loader and parser for LightRAG knowledge graphs.
"""

import logging
from pathlib import Path
from typing import Any

import networkx as nx
import pandas as pd

logger = logging.getLogger(__name__)


class GraphMLLoader:
    """Load and parse GraphML files generated by LightRAG."""

    def __init__(self, file_path: str | Path):
        """
        Initialize the GraphML loader.

        Args:
            file_path: Path to the GraphML file
        """
        self.file_path = Path(file_path)
        self.graph: nx.Graph | None = None
        self._node_df: pd.DataFrame | None = None
        self._edge_df: pd.DataFrame | None = None

    def load(self) -> nx.Graph:
        """
        Load the GraphML file into a NetworkX graph.

        Returns:
            NetworkX graph object
        """
        if not self.file_path.exists():
            raise FileNotFoundError(f"GraphML file not found: {self.file_path}")

        logger.info(f"Loading GraphML file: {self.file_path}")

        try:
            self.graph = nx.read_graphml(str(self.file_path))
            if self.graph is None:
                raise ValueError("Failed to load graph from file")
            logger.info(
                f"Loaded graph with {self.graph.number_of_nodes()} nodes and {self.graph.number_of_edges()} edges"
            )
            return self.graph
        except Exception as e:
            logger.error(f"Failed to load GraphML file: {e}")
            raise

    def get_node_data(self) -> pd.DataFrame:
        """
        Extract node data as a pandas DataFrame.

        Returns:
            DataFrame with node attributes
        """
        if self.graph is None:
            raise ValueError("Graph not loaded. Call load() first.")

        if self._node_df is None:
            nodes_data = []
            for node_id, data in self.graph.nodes(data=True):
                row = {"id": node_id}
                row.update(data)
                nodes_data.append(row)

            self._node_df = pd.DataFrame(nodes_data)

        return self._node_df

    def get_edge_data(self) -> pd.DataFrame:
        """
        Extract edge data as a pandas DataFrame.

        Returns:
            DataFrame with edge attributes
        """
        if self.graph is None:
            raise ValueError("Graph not loaded. Call load() first.")

        if self._edge_df is None:
            edges_data = []
            for source, target, data in self.graph.edges(data=True):
                row = {"source": source, "target": target}
                row.update(data)
                edges_data.append(row)

            self._edge_df = pd.DataFrame(edges_data)

        return self._edge_df

    def get_entity_types(self) -> list[str]:
        """
        Get unique entity types from the graph.

        Returns:
            List of entity types
        """
        node_df = self.get_node_data()
        if "entity_type" in node_df.columns:
            return sorted(node_df["entity_type"].dropna().unique())
        return []

    def filter_by_entity_type(self, entity_types: list[str]) -> nx.Graph:
        """
        Create a subgraph containing only nodes of specified entity types.

        Args:
            entity_types: List of entity types to include

        Returns:
            Filtered NetworkX graph
        """
        if self.graph is None:
            raise ValueError("Graph not loaded. Call load() first.")

        nodes_to_include = []
        for node_id, data in self.graph.nodes(data=True):
            if data.get("entity_type") in entity_types:
                nodes_to_include.append(node_id)

        return self.graph.subgraph(nodes_to_include).copy()

    def get_graph_statistics(self) -> dict[str, Any]:
        """
        Get basic statistics about the graph.

        Returns:
            Dictionary with graph statistics
        """
        if self.graph is None:
            raise ValueError("Graph not loaded. Call load() first.")

        stats = {
            "num_nodes": self.graph.number_of_nodes(),
            "num_edges": self.graph.number_of_edges(),
            "is_directed": nx.is_directed(self.graph),
            "is_connected": nx.is_connected(self.graph),
            "num_connected_components": nx.number_connected_components(self.graph),
        }

        # Add density
        stats["density"] = nx.density(self.graph)

        # Add degree statistics
        degree_sequence = list(self.graph.degree())
        if degree_sequence:
            degrees = [degree for node, degree in degree_sequence]
            stats["avg_degree"] = sum(degrees) / len(degrees)
            stats["max_degree"] = max(degrees)
            stats["min_degree"] = min(degrees)

        # Add entity type distribution
        node_df = self.get_node_data()
        if "entity_type" in node_df.columns:
            stats["entity_type_counts"] = (
                node_df["entity_type"].value_counts().to_dict()
            )

        return stats
