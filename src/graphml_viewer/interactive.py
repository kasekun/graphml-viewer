"""
Interactive Streamlit interface for exploring GraphML files.
"""

import logging
from pathlib import Path

import pandas as pd
import streamlit as st

# Handle imports - work both as relative imports and when run directly
try:
    from .analysis import GraphAnalyzer
    from .graph_loader import GraphMLLoader
    from .visualizer import GraphVisualizer
except ImportError:
    # If relative imports fail, try absolute imports
    from graphml_viewer.analysis import GraphAnalyzer
    from graphml_viewer.graph_loader import GraphMLLoader
    from graphml_viewer.visualizer import GraphVisualizer

logger = logging.getLogger(__name__)


class InteractiveViewer:
    """Streamlit-based interactive viewer for GraphML files."""

    def __init__(self):
        """Initialize the interactive viewer."""
        self.loader: GraphMLLoader | None = None
        self.visualizer: GraphVisualizer | None = None
        self.analyzer: GraphAnalyzer | None = None

    def run(self):
        """Run the Streamlit application."""
        st.set_page_config(
            page_title="GraphML Viewer",
            page_icon="üï∏Ô∏è",
            layout="wide",
            initial_sidebar_state="expanded",
        )

        st.title("üï∏Ô∏è GraphML Knowledge Graph Viewer")
        st.markdown("### Explore and visualize LightRAG knowledge graphs")

        # Sidebar for file upload and controls
        with st.sidebar:
            st.header("üìÅ Load GraphML File")

            # File upload
            uploaded_file = st.file_uploader(
                "Choose a GraphML file",
                type=["graphml", "xml"],
                help="Select a GraphML file generated by LightRAG",
            )

            # Example file path input
            st.markdown("**Or enter file path:**")
            file_path = st.text_input(
                "File path",
                placeholder="/path/to/your/graph.graphml",
                help="Enter the full path to your GraphML file",
                value="../light-rag/lightrag_data/graph_chunk_entity_relation.graphml",  # Default for convenience
            )

            # Load button
            load_clicked = st.button("üîÑ Load Graph", type="primary")

        # Main content area
        if load_clicked or uploaded_file:
            try:
                # Determine file path
                if uploaded_file:
                    # Save uploaded file temporarily
                    temp_path = Path("temp_graph.graphml")
                    with open(temp_path, "wb") as f:
                        f.write(uploaded_file.getbuffer())
                    graph_path = temp_path
                else:
                    graph_path = Path(file_path)

                # Load the graph
                with st.spinner("Loading GraphML file..."):
                    self.loader = GraphMLLoader(graph_path)
                    graph = self.loader.load()
                    self.visualizer = GraphVisualizer(graph)
                    self.analyzer = GraphAnalyzer(graph)

                st.success(
                    f"‚úÖ Loaded graph with {graph.number_of_nodes()} nodes and {graph.number_of_edges()} edges"
                )

                # Clean up temp file
                if uploaded_file and temp_path.exists():
                    temp_path.unlink()

                # Show the interface
                self._show_graph_interface()

            except Exception as e:
                st.error(f"‚ùå Error loading graph: {str(e)}")
                logger.error(f"Error loading graph: {e}")

        else:
            self._show_welcome_screen()

    def _show_welcome_screen(self):
        """Show the welcome screen when no graph is loaded."""
        col1, col2, col3 = st.columns([1, 2, 1])

        with col2:
            st.markdown("""
            ## Welcome to GraphML Viewer! üëã
            
            This tool helps you explore and visualize knowledge graphs created by LightRAG.
            
            ### Features:
            - üìä Interactive graph visualization
            - üîç Node and edge exploration
            - üìà Graph analytics and metrics
            - üé® Customizable styling and layouts
            - üîé Search and filtering capabilities
            
            ### Getting Started:
            1. Upload a GraphML file or enter the file path in the sidebar
            2. Click "Load Graph" to begin exploration
            3. Use the various tabs to analyze your knowledge graph
            
            ### Supported Files:
            - GraphML files (.graphml, .xml)
            - Generated by LightRAG or compatible tools
            """)

    def _show_graph_interface(self):
        """Show the main graph interface with tabs."""
        if not all([self.loader, self.visualizer, self.analyzer]):
            st.error("Graph not properly loaded")
            return

        # Create tabs
        tab1, tab2, tab3, tab4, tab5 = st.tabs(
            [
                "üìä Overview",
                "üï∏Ô∏è Visualization",
                "üîç Exploration",
                "üìà Analytics",
                "üìã Data Tables",
            ]
        )

        with tab1:
            self._show_overview_tab()

        with tab2:
            self._show_visualization_tab()

        with tab3:
            self._show_exploration_tab()

        with tab4:
            self._show_analytics_tab()

        with tab5:
            self._show_data_tables_tab()

    def _show_overview_tab(self):
        """Show graph overview and statistics."""
        st.header("üìä Graph Overview")

        # Get graph statistics
        stats = self.loader.get_graph_statistics()

        # Display key metrics
        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.metric("Nodes", stats["num_nodes"])

        with col2:
            st.metric("Edges", stats["num_edges"])

        with col3:
            st.metric("Density", f"{stats['density']:.3f}")

        with col4:
            st.metric("Connected Components", stats["num_connected_components"])

        # Entity type distribution
        if "entity_type_counts" in stats:
            st.subheader("üè∑Ô∏è Entity Type Distribution")

            # Create bar chart
            entity_df = pd.DataFrame(
                list(stats["entity_type_counts"].items()),
                columns=["Entity Type", "Count"],
            )
            st.bar_chart(entity_df.set_index("Entity Type"))

            # Show as table
            st.dataframe(entity_df, use_container_width=True)

    def _show_visualization_tab(self):
        """Show interactive graph visualization."""
        st.header("üï∏Ô∏è Graph Visualization")

        # Visualization controls
        col1, col2 = st.columns([1, 3])

        with col1:
            st.subheader("üéõÔ∏è Controls")

            # Layout selection
            layout = st.selectbox(
                "Layout Algorithm",
                ["spring", "circular", "random", "kamada_kawai", "spectral"],
                help="Choose the layout algorithm for positioning nodes",
            )

            # Node coloring
            color_by = st.selectbox(
                "Color nodes by",
                ["entity_type", "none"],
                help="Choose attribute for node coloring",
            )

            # Node sizing
            size_by = st.selectbox(
                "Size nodes by",
                ["degree", "uniform"],
                help="Choose attribute for node sizing",
            )

            # Apply styling
            if color_by != "none":
                color_map = self.visualizer.set_node_colors_by_attribute(color_by)

            if size_by == "degree":
                # Size by degree centrality
                degrees = dict(self.visualizer.graph.degree())
                max_degree = max(degrees.values()) if degrees else 1
                for node in self.visualizer.graph.nodes():
                    normalized_degree = degrees.get(node, 0) / max_degree
                    self.visualizer.node_sizes[node] = 20 + normalized_degree * 80

        with col2:
            st.subheader("üìä Interactive Plot")

            try:
                # Create plotly visualization
                fig = self.visualizer.plot_plotly(
                    layout=layout,
                    node_label_attr="entity_id",
                    title="Knowledge Graph Visualization",
                )

                st.plotly_chart(fig, use_container_width=True)

            except Exception as e:
                st.error(f"Error creating visualization: {str(e)}")

                # Fallback to matplotlib
                st.info("Falling back to static matplotlib plot...")
                try:
                    fig = self.visualizer.plot_matplotlib(
                        layout=layout, node_label_attr="entity_id"
                    )
                    st.pyplot(fig)
                except Exception as e2:
                    st.error(f"Visualization failed: {str(e2)}")

    def _show_exploration_tab(self):
        """Show node and edge exploration interface."""
        st.header("üîç Graph Exploration")

        # Search functionality
        st.subheader("üîé Search Nodes")
        search_term = st.text_input(
            "Search for nodes", placeholder="Enter node ID or entity name"
        )

        if search_term:
            # Find matching nodes
            node_df = self.loader.get_node_data()
            matching_nodes = node_df[
                node_df.astype(str).apply(
                    lambda row: row.str.contains(
                        search_term, case=False, na=False
                    ).any(),
                    axis=1,
                )
            ]

            st.write(f"Found {len(matching_nodes)} matching nodes:")
            st.dataframe(matching_nodes, use_container_width=True)

        # Node neighborhood exploration
        st.subheader("üéØ Node Neighborhood")

        col1, col2 = st.columns([1, 1])

        with col1:
            # Node selection
            all_nodes = list(self.visualizer.graph.nodes())
            selected_node = st.selectbox(
                "Select a node to explore",
                all_nodes,
                help="Choose a node to view its neighborhood",
            )

            max_distance = st.slider(
                "Maximum distance",
                min_value=1,
                max_value=3,
                value=2,
                help="Maximum distance from selected node",
            )

        with col2:
            if selected_node:
                # Get node information
                node_data = dict(self.visualizer.graph.nodes[selected_node])
                st.write("**Node Information:**")
                for key, value in node_data.items():
                    st.write(f"- **{key}:** {value}")

                # Show neighbors
                neighbors = list(self.visualizer.graph.neighbors(selected_node))
                st.write(f"**Direct neighbors ({len(neighbors)}):**")
                for neighbor in neighbors[:10]:  # Show first 10
                    st.write(f"- {neighbor}")
                if len(neighbors) > 10:
                    st.write(f"... and {len(neighbors) - 10} more")

        # Visualize neighborhood
        if selected_node:
            try:
                subgraph = self.analyzer.get_subgraph_by_distance(
                    selected_node, max_distance
                )

                if subgraph.number_of_nodes() > 0:
                    st.subheader(f"üï∏Ô∏è Neighborhood of '{selected_node}'")

                    # Create visualizer for subgraph
                    sub_visualizer = GraphVisualizer(subgraph)

                    # Highlight the center node
                    for node in subgraph.nodes():
                        if node == selected_node:
                            sub_visualizer.node_colors[node] = (
                                "#ff0000"  # Red for center
                            )
                        else:
                            sub_visualizer.node_colors[node] = (
                                "#1f78b4"  # Blue for others
                            )

                    fig = sub_visualizer.plot_plotly(
                        title=f"Neighborhood of {selected_node} (distance ‚â§ {max_distance})"
                    )
                    st.plotly_chart(fig, use_container_width=True)

                    st.info(
                        f"Showing {subgraph.number_of_nodes()} nodes and {subgraph.number_of_edges()} edges"
                    )

            except Exception as e:
                st.error(f"Error visualizing neighborhood: {str(e)}")

    def _show_analytics_tab(self):
        """Show graph analytics and metrics."""
        st.header("üìà Graph Analytics")

        # Centrality measures
        st.subheader("üéØ Node Importance (Centrality)")

        with st.spinner("Computing centrality measures..."):
            centrality_measures = self.analyzer.compute_centrality_measures()

        # Allow user to select centrality measure
        centrality_type = st.selectbox(
            "Centrality measure",
            list(centrality_measures.keys()),
            help="Choose which centrality measure to display",
        )

        # Show top nodes
        top_k = st.slider("Number of top nodes to show", 5, 20, 10)
        ranking = self.analyzer.get_node_importance_ranking(centrality_type, top_k)

        # Display ranking
        ranking_df = pd.DataFrame(ranking, columns=["Node", "Score"])
        st.dataframe(ranking_df, use_container_width=True)

        # Community detection
        st.subheader("üë• Community Detection")

        community_method = st.selectbox(
            "Community detection method",
            ["greedy", "label_propagation"],
            help="Choose the community detection algorithm",
        )

        with st.spinner("Detecting communities..."):
            try:
                communities = self.analyzer.find_communities(community_method)

                # Show community statistics
                community_sizes = {}
                for node, community_id in communities.items():
                    community_sizes[community_id] = (
                        community_sizes.get(community_id, 0) + 1
                    )

                st.write(f"Found {len(community_sizes)} communities:")

                community_df = pd.DataFrame(
                    [
                        {"Community ID": cid, "Size": size}
                        for cid, size in sorted(community_sizes.items())
                    ]
                )
                st.dataframe(community_df, use_container_width=True)

            except Exception as e:
                st.error(f"Community detection failed: {str(e)}")

        # Entity type connectivity
        st.subheader("üîó Entity Type Connectivity")

        with st.spinner("Analyzing entity type connectivity..."):
            connectivity_analysis = self.analyzer.analyze_entity_type_connectivity()

        # Show type connections
        st.write("**Connections between entity types:**")
        type_connections = connectivity_analysis["type_connections"]

        connection_data = []
        for (type1, type2), count in type_connections.items():
            connection_data.append(
                {"Type 1": type1, "Type 2": type2, "Connection Count": count}
            )

        if connection_data:
            connection_df = pd.DataFrame(connection_data)
            st.dataframe(connection_df, use_container_width=True)

    def _show_data_tables_tab(self):
        """Show raw data tables."""
        st.header("üìã Data Tables")

        # Node data
        st.subheader("üîµ Node Data")
        node_df = self.loader.get_node_data()

        # Add filters
        if "entity_type" in node_df.columns:
            entity_types = ["All"] + list(node_df["entity_type"].dropna().unique())
            selected_type = st.selectbox("Filter by entity type", entity_types)

            if selected_type != "All":
                node_df = node_df[node_df["entity_type"] == selected_type]

        st.dataframe(node_df, use_container_width=True)
        st.write(f"Showing {len(node_df)} nodes")

        # Edge data
        st.subheader("üîó Edge Data")
        edge_df = self.loader.get_edge_data()
        st.dataframe(edge_df, use_container_width=True)
        st.write(f"Showing {len(edge_df)} edges")


# For direct execution with streamlit run
if __name__ == "__main__":
    viewer = InteractiveViewer()
    viewer.run()
